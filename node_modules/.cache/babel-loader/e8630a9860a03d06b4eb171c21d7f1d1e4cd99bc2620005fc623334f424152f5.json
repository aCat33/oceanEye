{"ast":null,"code":"// 地图瓦片源配置\nexport const TILE_SOURCES = {\n  ONLINE: {\n    url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',\n    name: '在线 (CartoDB Dark)',\n    attribution: '&copy; OpenStreetMap &copy; CARTO'\n  },\n  OFFLINE: {\n    url: 'http://localhost:8080/tiles/{z}/{x}/{y}.png',\n    name: '离线 (本地服务器)',\n    attribution: '&copy; Local Data'\n  }\n};\n\n// 偏航阈值 (海里)\nexport const DEVIATION_THRESHOLD_NM = 5.0;\n\n// 辅助算法：计算点到线段的最短距离 (米)\nexport const getDistanceToSegmentMeters = (pLat, pLon, vLat, vLon, wLat, wLon) => {\n  const latToM = 111132;\n  const lonToM = 111132 * Math.cos(pLat * Math.PI / 180);\n  const x = pLon * lonToM;\n  const y = pLat * latToM;\n  const x1 = vLon * lonToM;\n  const y1 = vLat * latToM;\n  const x2 = wLon * lonToM;\n  const y2 = wLat * latToM;\n  const l2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n  if (l2 === 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;\n  t = Math.max(0, Math.min(1, t));\n  const projX = x1 + t * (x2 - x1);\n  const projY = y1 + t * (y2 - y1);\n  return Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));\n};\n\n// 核心算法：计算点到多段线的最短距离 (返回海里)\nexport const calculateCrossTrackError = (shipLat, shipLon, routePoints) => {\n  if (!routePoints || routePoints.length < 2) return 0;\n  let minDistanceMeters = Infinity;\n  for (let i = 0; i < routePoints.length - 1; i++) {\n    const p1 = routePoints[i];\n    const p2 = routePoints[i + 1];\n    const dist = getDistanceToSegmentMeters(shipLat, shipLon, p1[0], p1[1], p2[0], p2[1]);\n    if (dist < minDistanceMeters) minDistanceMeters = dist;\n  }\n  return minDistanceMeters / 1852;\n};\n\n// 辅助算法：计算目标点 (用于风圈绘制)\nexport const calculateDestinationPoint = (startLat, startLon, distanceMeters, bearing) => {\n  const R = 6378137;\n  const δ = distanceMeters / R;\n  const θ = bearing * (Math.PI / 180);\n  const φ1 = startLat * (Math.PI / 180);\n  const λ1 = startLon * (Math.PI / 180);\n  const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));\n  const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));\n  return [φ2 * (180 / Math.PI), λ2 * (180 / Math.PI)];\n};\n\n// 辅助算法：生成四象限风圈多边形\nexport const generateWindCirclePoints = (center, radiiObj) => {\n  const points = [];\n  const step = 5;\n  for (let angle = 0; angle <= 360; angle += step) {\n    let r_km = 0;\n    if (angle >= 0 && angle < 90) r_km = radiiObj.ne;else if (angle >= 90 && angle < 180) r_km = radiiObj.se;else if (angle >= 180 && angle < 270) r_km = radiiObj.sw;else r_km = radiiObj.nw;\n    points.push(calculateDestinationPoint(center[0], center[1], r_km * 1000, angle));\n  }\n  return points;\n};","map":{"version":3,"names":["TILE_SOURCES","ONLINE","url","name","attribution","OFFLINE","DEVIATION_THRESHOLD_NM","getDistanceToSegmentMeters","pLat","pLon","vLat","vLon","wLat","wLon","latToM","lonToM","Math","cos","PI","x","y","x1","y1","x2","y2","l2","sqrt","t","max","min","projX","projY","calculateCrossTrackError","shipLat","shipLon","routePoints","length","minDistanceMeters","Infinity","i","p1","p2","dist","calculateDestinationPoint","startLat","startLon","distanceMeters","bearing","R","δ","θ","φ1","λ1","φ2","asin","sin","λ2","atan2","generateWindCirclePoints","center","radiiObj","points","step","angle","r_km","ne","se","sw","nw","push"],"sources":["C:/Users/10211/Desktop/AI Files/oceanEye/src/utils/mapUtils.js"],"sourcesContent":["// 地图瓦片源配置\r\nexport const TILE_SOURCES = {\r\n    ONLINE: {\r\n        url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',\r\n        name: '在线 (CartoDB Dark)',\r\n        attribution: '&copy; OpenStreetMap &copy; CARTO'\r\n    },\r\n    OFFLINE: {\r\n        url: 'http://localhost:8080/tiles/{z}/{x}/{y}.png', \r\n        name: '离线 (本地服务器)',\r\n        attribution: '&copy; Local Data'\r\n    }\r\n};\r\n\r\n// 偏航阈值 (海里)\r\nexport const DEVIATION_THRESHOLD_NM = 5.0; \r\n\r\n// 辅助算法：计算点到线段的最短距离 (米)\r\nexport const getDistanceToSegmentMeters = (pLat, pLon, vLat, vLon, wLat, wLon) => {\r\n    const latToM = 111132;\r\n    const lonToM = 111132 * Math.cos(pLat * Math.PI / 180);\r\n    const x = pLon * lonToM; const y = pLat * latToM;\r\n    const x1 = vLon * lonToM; const y1 = vLat * latToM;\r\n    const x2 = wLon * lonToM; const y2 = wLat * latToM;\r\n    const l2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\r\n    if (l2 === 0) return Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1));\r\n    let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n    const projX = x1 + t * (x2 - x1);\r\n    const projY = y1 + t * (y2 - y1);\r\n    return Math.sqrt((x - projX)*(x - projX) + (y - projY)*(y - projY));\r\n};\r\n\r\n// 核心算法：计算点到多段线的最短距离 (返回海里)\r\nexport const calculateCrossTrackError = (shipLat, shipLon, routePoints) => {\r\n    if (!routePoints || routePoints.length < 2) return 0;\r\n    let minDistanceMeters = Infinity;\r\n    for (let i = 0; i < routePoints.length - 1; i++) {\r\n        const p1 = routePoints[i];\r\n        const p2 = routePoints[i+1];\r\n        const dist = getDistanceToSegmentMeters(shipLat, shipLon, p1[0], p1[1], p2[0], p2[1]);\r\n        if (dist < minDistanceMeters) minDistanceMeters = dist;\r\n    }\r\n    return minDistanceMeters / 1852;\r\n};\r\n\r\n// 辅助算法：计算目标点 (用于风圈绘制)\r\nexport const calculateDestinationPoint = (startLat, startLon, distanceMeters, bearing) => {\r\n    const R = 6378137;\r\n    const δ = distanceMeters / R;\r\n    const θ = bearing * (Math.PI / 180);\r\n    const φ1 = startLat * (Math.PI / 180);\r\n    const λ1 = startLon * (Math.PI / 180);\r\n    const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));\r\n    const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));\r\n    return [φ2 * (180 / Math.PI), λ2 * (180 / Math.PI)];\r\n};\r\n\r\n// 辅助算法：生成四象限风圈多边形\r\nexport const generateWindCirclePoints = (center, radiiObj) => {\r\n    const points = []; const step = 5;\r\n    for (let angle = 0; angle <= 360; angle += step) {\r\n        let r_km = 0;\r\n        if (angle >= 0 && angle < 90) r_km = radiiObj.ne;\r\n        else if (angle >= 90 && angle < 180) r_km = radiiObj.se;\r\n        else if (angle >= 180 && angle < 270) r_km = radiiObj.sw;\r\n        else r_km = radiiObj.nw;\r\n        points.push(calculateDestinationPoint(center[0], center[1], r_km * 1000, angle));\r\n    }\r\n    return points;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}